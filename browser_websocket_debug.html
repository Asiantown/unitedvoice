<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>United Voice Agent - WebSocket Network Debugger</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: white;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .debug-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .debug-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e6ed;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #2d3748;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 10px;
        }

        .status-connected { background-color: #10b981; }
        .status-disconnected { background-color: #ef4444; }
        .status-connecting { background-color: #f59e0b; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-danger {
            background: #fe5f55;
            color: white;
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .log-container {
            background: #1a202c;
            color: #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }

        .log-info { background-color: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; }
        .log-success { background-color: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; }
        .log-warning { background-color: rgba(245, 158, 11, 0.1); border-left: 3px solid #f59e0b; }
        .log-error { background-color: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; }

        .timestamp {
            color: #9ca3af;
            font-size: 0.8em;
        }

        .frame-inspector {
            max-height: 300px;
            overflow-y: auto;
        }

        .frame-entry {
            margin-bottom: 10px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
        }

        .frame-header {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .frame-data {
            background: #edf2f7;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 100px;
            overflow-y: auto;
        }

        .network-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #2d3748;
        }

        .stat-label {
            color: #718096;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .audio-controls {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .audio-visualizer {
            height: 80px;
            background: #1a202c;
            border-radius: 8px;
            display: flex;
            align-items: end;
            justify-content: center;
            padding: 10px;
            gap: 2px;
        }

        .audio-bar {
            width: 4px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .transport-test {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .transport-status {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .connection-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9em;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .security-check {
            background: #fef5e7;
            border: 1px solid #f6ad55;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .security-pass { background: #f0fff4; border-color: #38a169; }
        .security-fail { background: #fed7d7; border-color: #e53e3e; }

        .error-details {
            background: #fed7d7;
            border: 1px solid #e53e3e;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .recommendations {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .recommendation-list {
            list-style: none;
        }

        .recommendation-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .recommendation-list li::before {
            content: "üí°";
            position: absolute;
            left: 0;
        }

        @media (max-width: 768px) {
            .debug-grid {
                grid-template-columns: 1fr;
            }
            .connection-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç WebSocket Network Debugger</h1>
        
        <!-- Main Controls -->
        <div class="debug-panel full-width">
            <div class="panel-header">
                <div class="panel-title">Connection Controls</div>
                <div id="connectionStatus" class="status-indicator status-disconnected"></div>
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" id="connectBtn">Connect WebSocket</button>
                <button class="btn btn-secondary" id="disconnectBtn">Disconnect</button>
                <button class="btn btn-success" id="testAudioBtn">Test Audio Recording</button>
                <button class="btn btn-danger" id="clearLogsBtn">Clear Logs</button>
                <button class="btn btn-secondary" id="exportLogsBtn">Export Debug Data</button>
            </div>

            <!-- Transport Method Testing -->
            <div class="transport-test">
                <label>Transport Method:</label>
                <select id="transportSelect">
                    <option value="websocket,polling">Auto (WebSocket + Polling Fallback)</option>
                    <option value="websocket">WebSocket Only</option>
                    <option value="polling">Polling Only</option>
                </select>
                <div id="currentTransport" class="transport-status">Not Connected</div>
            </div>

            <!-- Connection Timeout Testing -->
            <div class="transport-test">
                <label>Connection Timeout:</label>
                <select id="timeoutSelect">
                    <option value="2000">2 seconds</option>
                    <option value="5000" selected>5 seconds</option>
                    <option value="10000">10 seconds</option>
                    <option value="20000">20 seconds</option>
                </select>
                <label>Reconnection Attempts:</label>
                <input type="number" id="reconnectAttempts" value="5" min="0" max="20" style="width: 60px;">
            </div>
        </div>

        <div class="debug-grid">
            <!-- Connection Details -->
            <div class="debug-panel">
                <div class="panel-header">
                    <div class="panel-title">Connection Details</div>
                </div>
                
                <div class="connection-details">
                    <div class="detail-row">
                        <span>Server URL:</span>
                        <span id="serverUrl">http://localhost:8000</span>
                    </div>
                    <div class="detail-row">
                        <span>Socket.IO Version:</span>
                        <span id="socketVersion">Loading...</span>
                    </div>
                    <div class="detail-row">
                        <span>Browser:</span>
                        <span id="browserInfo">Loading...</span>
                    </div>
                    <div class="detail-row">
                        <span>WebSocket Support:</span>
                        <span id="wsSupport">Loading...</span>
                    </div>
                    <div class="detail-row">
                        <span>Connection Time:</span>
                        <span id="connectionTime">Not Connected</span>
                    </div>
                    <div class="detail-row">
                        <span>Ping Time:</span>
                        <span id="pingTime">Not Available</span>
                    </div>
                </div>

                <!-- Security Check -->
                <div id="securityCheck" class="security-check">
                    <h4>üîí Security & CORS Check</h4>
                    <div id="securityDetails">Running checks...</div>
                </div>
            </div>

            <!-- Network Statistics -->
            <div class="debug-panel">
                <div class="panel-header">
                    <div class="panel-title">Network Statistics</div>
                </div>
                
                <div class="network-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="messagesOut">0</div>
                        <div class="stat-label">Messages Sent</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="messagesIn">0</div>
                        <div class="stat-label">Messages Received</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bytesOut">0</div>
                        <div class="stat-label">Bytes Sent</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bytesIn">0</div>
                        <div class="stat-label">Bytes Received</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="reconnects">0</div>
                        <div class="stat-label">Reconnections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="errors">0</div>
                        <div class="stat-label">Errors</div>
                    </div>
                </div>
            </div>

            <!-- Audio Testing -->
            <div class="debug-panel">
                <div class="panel-header">
                    <div class="panel-title">Audio Testing</div>
                </div>
                
                <div class="audio-controls">
                    <div class="audio-visualizer" id="audioVisualizer">
                        <!-- Audio bars will be created dynamically -->
                    </div>
                    <div>
                        <button class="btn btn-primary" id="recordBtn">Record Audio</button>
                        <button class="btn btn-secondary" id="stopBtn" disabled>Stop</button>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <div class="detail-row">
                        <span>Microphone Access:</span>
                        <span id="micAccess">Not Requested</span>
                    </div>
                    <div class="detail-row">
                        <span>Audio Format:</span>
                        <span id="audioFormat">Not Recording</span>
                    </div>
                    <div class="detail-row">
                        <span>Sample Rate:</span>
                        <span id="sampleRate">Not Recording</span>
                    </div>
                </div>
            </div>

            <!-- Frame Inspector -->
            <div class="debug-panel">
                <div class="panel-header">
                    <div class="panel-title">WebSocket Frame Inspector</div>
                </div>
                <div class="frame-inspector" id="frameInspector">
                    <div class="log-entry log-info">No frames captured yet. Connect to start monitoring.</div>
                </div>
            </div>

            <!-- Debug Logs -->
            <div class="debug-panel full-width">
                <div class="panel-header">
                    <div class="panel-title">Debug Logs</div>
                </div>
                <div class="log-container" id="debugLogs">
                    <div class="log-entry log-info">
                        <span class="timestamp">[System Startup]</span> WebSocket debugger initialized
                    </div>
                </div>
            </div>
        </div>

        <!-- Recommendations Panel -->
        <div class="debug-panel full-width recommendations" id="recommendationsPanel" style="display: none;">
            <h3>üîß Recommendations & Issues Found</h3>
            <ul class="recommendation-list" id="recommendationsList">
            </ul>
        </div>
    </div>

    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Global state
        let socket = null;
        let audioStream = null;
        let mediaRecorder = null;
        let isRecording = false;
        let connectionStartTime = null;
        let stats = {
            messagesOut: 0,
            messagesIn: 0,
            bytesOut: 0,
            bytesIn: 0,
            reconnects: 0,
            errors: 0
        };
        let recommendations = new Set();

        // DOM elements
        const elements = {
            connectBtn: document.getElementById('connectBtn'),
            disconnectBtn: document.getElementById('disconnectBtn'),
            testAudioBtn: document.getElementById('testAudioBtn'),
            clearLogsBtn: document.getElementById('clearLogsBtn'),
            exportLogsBtn: document.getElementById('exportLogsBtn'),
            recordBtn: document.getElementById('recordBtn'),
            stopBtn: document.getElementById('stopBtn'),
            connectionStatus: document.getElementById('connectionStatus'),
            transportSelect: document.getElementById('transportSelect'),
            timeoutSelect: document.getElementById('timeoutSelect'),
            reconnectAttempts: document.getElementById('reconnectAttempts'),
            currentTransport: document.getElementById('currentTransport'),
            debugLogs: document.getElementById('debugLogs'),
            frameInspector: document.getElementById('frameInspector'),
            audioVisualizer: document.getElementById('audioVisualizer'),
            securityCheck: document.getElementById('securityCheck'),
            securityDetails: document.getElementById('securityDetails'),
            recommendationsPanel: document.getElementById('recommendationsPanel'),
            recommendationsList: document.getElementById('recommendationsList')
        };

        // Logging function
        function log(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            let content = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            if (data) {
                content += `<br><pre style="margin-top: 5px; font-size: 0.8em;">${JSON.stringify(data, null, 2)}</pre>`;
            }
            
            logEntry.innerHTML = content;
            elements.debugLogs.appendChild(logEntry);
            elements.debugLogs.scrollTop = elements.debugLogs.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`, data || '');
        }

        // Frame inspector
        function logFrame(direction, event, data) {
            const timestamp = new Date().toLocaleTimeString();
            const frameEntry = document.createElement('div');
            frameEntry.className = 'frame-entry';
            
            const header = document.createElement('div');
            header.className = 'frame-header';
            header.textContent = `${direction} ${event} - ${timestamp}`;
            
            const dataDiv = document.createElement('div');
            dataDiv.className = 'frame-data';
            dataDiv.textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            
            frameEntry.appendChild(header);
            frameEntry.appendChild(dataDiv);
            
            elements.frameInspector.insertBefore(frameEntry, elements.frameInspector.firstChild);
            
            // Keep only last 20 frames
            while (elements.frameInspector.children.length > 20) {
                elements.frameInspector.removeChild(elements.frameInspector.lastChild);
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('messagesOut').textContent = stats.messagesOut;
            document.getElementById('messagesIn').textContent = stats.messagesIn;
            document.getElementById('bytesOut').textContent = formatBytes(stats.bytesOut);
            document.getElementById('bytesIn').textContent = formatBytes(stats.bytesIn);
            document.getElementById('reconnects').textContent = stats.reconnects;
            document.getElementById('errors').textContent = stats.errors;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Browser info detection
        function detectBrowserInfo() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            
            if (ua.includes('Chrome')) browser = 'Chrome';
            else if (ua.includes('Firefox')) browser = 'Firefox';
            else if (ua.includes('Safari')) browser = 'Safari';
            else if (ua.includes('Edge')) browser = 'Edge';
            
            document.getElementById('browserInfo').textContent = browser;
            document.getElementById('wsSupport').textContent = 'WebSocket' in window ? 'Supported' : 'Not Supported';
            
            // Add browser-specific recommendations
            if (browser === 'Chrome' && location.protocol === 'file:') {
                recommendations.add('Chrome requires HTTPS or localhost for WebRTC features. Consider using a local server.');
            }
            
            if (browser === 'Safari') {
                recommendations.add('Safari has stricter WebRTC policies. Ensure user gesture before audio access.');
            }
        }

        // CORS and security check
        async function runSecurityCheck() {
            const serverUrl = elements.transportSelect.value || 'http://localhost:8000';
            let issues = [];
            let passes = [];
            
            try {
                // Check if we can reach the server
                const response = await fetch(`${serverUrl}/health`, { mode: 'cors' });
                if (response.ok) {
                    passes.push('‚úÖ Server reachable via HTTP');
                    
                    // Check CORS headers
                    const corsHeaders = [
                        'access-control-allow-origin',
                        'access-control-allow-methods',
                        'access-control-allow-headers'
                    ];
                    
                    let corsInfo = [];
                    corsHeaders.forEach(header => {
                        const value = response.headers.get(header);
                        if (value) {
                            corsInfo.push(`${header}: ${value}`);
                        }
                    });
                    
                    if (corsInfo.length > 0) {
                        passes.push('‚úÖ CORS headers present');
                        log('CORS headers detected', 'success', corsInfo);
                    } else {
                        issues.push('‚ö†Ô∏è No CORS headers detected');
                        recommendations.add('Server should include proper CORS headers for cross-origin requests.');
                    }
                    
                } else {
                    issues.push(`‚ùå Server responded with status: ${response.status}`);
                }
            } catch (error) {
                issues.push(`‚ùå Cannot reach server: ${error.message}`);
                recommendations.add('Ensure the backend server is running on the specified port.');
            }
            
            // Check protocol mismatch
            if (location.protocol === 'https:' && serverUrl.startsWith('http:')) {
                issues.push('‚ö†Ô∏è Mixed content: HTTPS page trying to connect to HTTP WebSocket');
                recommendations.add('Use HTTPS for the WebSocket server or serve this page over HTTP.');
            }
            
            // Check localhost vs 127.0.0.1
            if (serverUrl.includes('127.0.0.1') && location.hostname === 'localhost') {
                recommendations.add('Consider using consistent hostnames (localhost vs 127.0.0.1) to avoid connection issues.');
            }
            
            // Update security panel
            const securityClass = issues.length > 0 ? 'security-fail' : 'security-pass';
            elements.securityCheck.className = `security-check ${securityClass}`;
            
            const allChecks = [...passes, ...issues];
            elements.securityDetails.innerHTML = allChecks.join('<br>');
            
            if (issues.length > 0) {
                log('Security/CORS issues detected', 'warning', issues);
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            if (socket && socket.connected) {
                log('Already connected to WebSocket', 'warning');
                return;
            }
            
            const serverUrl = document.getElementById('serverUrl').textContent;
            const transport = elements.transportSelect.value.split(',');
            const timeout = parseInt(elements.timeoutSelect.value);
            const reconnectionAttempts = parseInt(elements.reconnectAttempts.value);
            
            log(`Attempting connection to ${serverUrl}`, 'info', {
                transport,
                timeout,
                reconnectionAttempts
            });
            
            elements.connectionStatus.className = 'status-indicator status-connecting';
            connectionStartTime = Date.now();
            
            socket = io(serverUrl, {
                transports: transport,
                timeout: timeout,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: reconnectionAttempts,
                forceNew: true
            });
            
            // Connection events
            socket.on('connect', () => {
                const connectTime = Date.now() - connectionStartTime;
                elements.connectionStatus.className = 'status-indicator status-connected';
                elements.currentTransport.textContent = socket.io.engine.transport.name;
                elements.currentTransport.className = 'transport-status';
                document.getElementById('connectionTime').textContent = `${connectTime}ms`;
                
                log(`Connected successfully in ${connectTime}ms`, 'success', {
                    transport: socket.io.engine.transport.name,
                    id: socket.id
                });
                
                // Start ping monitoring
                monitorPing();
            });
            
            socket.on('connect_error', (error) => {
                elements.connectionStatus.className = 'status-indicator status-disconnected';
                elements.currentTransport.textContent = 'Connection Failed';
                elements.currentTransport.className = 'transport-status';
                stats.errors++;
                updateStats();
                
                log('Connection error', 'error', {
                    message: error.message,
                    description: error.description,
                    type: error.type
                });
                
                // Analyze connection error
                if (error.message.includes('ECONNREFUSED')) {
                    recommendations.add('Server is not running or not accepting connections on the specified port.');
                } else if (error.message.includes('timeout')) {
                    recommendations.add('Connection timeout. Try increasing the timeout value or check network connectivity.');
                } else if (error.message.includes('CORS')) {
                    recommendations.add('CORS policy blocking the connection. Check server CORS configuration.');
                }
                
                updateRecommendations();
            });
            
            socket.on('disconnect', (reason) => {
                elements.connectionStatus.className = 'status-indicator status-disconnected';
                elements.currentTransport.textContent = 'Disconnected';
                document.getElementById('pingTime').textContent = 'Not Available';
                
                log('Disconnected', 'warning', { reason });
                
                if (reason === 'io server disconnect') {
                    recommendations.add('Server initiated disconnection. Check server logs for issues.');
                } else if (reason === 'transport close') {
                    recommendations.add('Transport layer closed. This might indicate network issues.');
                }
                
                updateRecommendations();
            });
            
            socket.on('reconnect', (attemptNumber) => {
                stats.reconnects++;
                updateStats();
                log(`Reconnected after ${attemptNumber} attempts`, 'success');
            });
            
            socket.on('reconnect_error', (error) => {
                stats.errors++;
                updateStats();
                log('Reconnection failed', 'error', error);
            });
            
            // Monitor all events for frame inspection
            socket.onAny((event, ...args) => {
                logFrame('üì• IN', event, args.length === 1 ? args[0] : args);
                stats.messagesIn++;
                
                // Estimate bytes (rough calculation)
                const dataSize = JSON.stringify(args).length;
                stats.bytesIn += dataSize;
                updateStats();
            });
            
            // Intercept outgoing messages
            const originalEmit = socket.emit;
            socket.emit = function(event, ...args) {
                logFrame('üì§ OUT', event, args.length === 1 ? args[0] : args);
                stats.messagesOut++;
                
                // Estimate bytes
                const dataSize = JSON.stringify([event, ...args]).length;
                stats.bytesOut += dataSize;
                updateStats();
                
                return originalEmit.apply(this, [event, ...args]);
            };
            
            // Voice-specific event handlers
            socket.on('transcription', (data) => {
                log('Received transcription', 'success', data);
            });
            
            socket.on('agent_response', (data) => {
                log('Received agent response', 'success', {
                    textLength: data.text?.length,
                    hasAudio: !!data.audio,
                    audioFormat: data.audio_format
                });
            });
            
            socket.on('status_update', (data) => {
                log('Status update', 'info', data);
            });
            
            socket.on('error', (error) => {
                stats.errors++;
                updateStats();
                log('Socket error', 'error', error);
            });
        }
        
        function disconnectWebSocket() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            elements.connectionStatus.className = 'status-indicator status-disconnected';
            elements.currentTransport.textContent = 'Disconnected';
        }
        
        // Ping monitoring
        function monitorPing() {
            if (!socket || !socket.connected) return;
            
            const start = Date.now();
            socket.emit('ping', start, (response) => {
                const ping = Date.now() - start;
                document.getElementById('pingTime').textContent = `${ping}ms`;
                
                if (ping > 1000) {
                    recommendations.add('High latency detected. Check network connection quality.');
                    updateRecommendations();
                }
            });
            
            // Schedule next ping
            setTimeout(() => monitorPing(), 5000);
        }
        
        // Audio testing
        async function testAudioRecording() {
            try {
                document.getElementById('micAccess').textContent = 'Requesting...';
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                audioStream = stream;
                document.getElementById('micAccess').textContent = 'Granted';
                
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                source.connect(analyser);
                
                document.getElementById('sampleRate').textContent = `${audioContext.sampleRate} Hz`;
                
                // Create audio visualizer
                createAudioVisualizer(analyser);
                
                elements.recordBtn.disabled = false;
                log('Audio access granted', 'success', {
                    sampleRate: audioContext.sampleRate,
                    channels: stream.getAudioTracks()[0].getSettings().channelCount
                });
                
            } catch (error) {
                document.getElementById('micAccess').textContent = 'Denied';
                log('Audio access denied', 'error', error);
                
                if (error.name === 'NotAllowedError') {
                    recommendations.add('Microphone access denied. Check browser permissions.');
                } else if (error.name === 'NotFoundError') {
                    recommendations.add('No microphone found. Check audio device connections.');
                }
                
                updateRecommendations();
            }
        }
        
        // Audio visualizer
        function createAudioVisualizer(analyser) {
            const canvas = document.createElement('canvas');
            canvas.width = elements.audioVisualizer.clientWidth;
            canvas.height = elements.audioVisualizer.clientHeight;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            elements.audioVisualizer.innerHTML = '';
            elements.audioVisualizer.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            function draw() {
                if (!audioStream) return;
                
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = '#1a202c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / dataArray.length * 2.5;
                let x = 0;
                
                for (let i = 0; i < dataArray.length; i += 4) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    const gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 2;
                }
            }
            
            draw();
        }
        
        // Start recording
        function startRecording() {
            if (!audioStream) {
                log('No audio stream available', 'error');
                return;
            }
            
            try {
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'audio/mp4';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            delete options.mimeType;
                        }
                    }
                }
                
                mediaRecorder = new MediaRecorder(audioStream, options);
                const chunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(chunks, { type: mediaRecorder.mimeType });
                    document.getElementById('audioFormat').textContent = mediaRecorder.mimeType;
                    
                    log('Audio recorded', 'success', {
                        format: mediaRecorder.mimeType,
                        size: audioBlob.size
                    });
                    
                    // Send audio to WebSocket if connected
                    if (socket && socket.connected) {
                        sendAudioData(audioBlob);
                    } else {
                        log('Cannot send audio: WebSocket not connected', 'warning');
                    }
                };
                
                mediaRecorder.start(1000); // Record in 1-second chunks
                isRecording = true;
                elements.recordBtn.disabled = true;
                elements.stopBtn.disabled = false;
                
                log('Recording started', 'info', { format: mediaRecorder.mimeType });
                
            } catch (error) {
                log('Failed to start recording', 'error', error);
                recommendations.add('MediaRecorder not supported or configuration issue.');
                updateRecommendations();
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
                log('Recording stopped', 'info');
            }
        }
        
        // Send audio data
        function sendAudioData(audioBlob) {
            if (!socket || !socket.connected) {
                log('Cannot send audio: WebSocket not connected', 'warning');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = () => {
                const base64Audio = reader.result.split(',')[1];
                const audioData = {
                    audio: base64Audio,
                    format: audioBlob.type.split('/')[1] || 'webm',
                    timestamp: new Date().toISOString(),
                    size: audioBlob.size
                };
                
                socket.emit('audio_data', audioData);
                log('Audio data sent', 'info', {
                    format: audioData.format,
                    size: audioData.size
                });
            };
            reader.readAsDataURL(audioBlob);
        }
        
        // Update recommendations panel
        function updateRecommendations() {
            if (recommendations.size > 0) {
                elements.recommendationsList.innerHTML = '';
                recommendations.forEach(rec => {
                    const li = document.createElement('li');
                    li.textContent = rec;
                    elements.recommendationsList.appendChild(li);
                });
                elements.recommendationsPanel.style.display = 'block';
            }
        }
        
        // Export debug data
        function exportDebugData() {
            const debugData = {
                timestamp: new Date().toISOString(),
                browser: document.getElementById('browserInfo').textContent,
                wsSupport: document.getElementById('wsSupport').textContent,
                serverUrl: document.getElementById('serverUrl').textContent,
                stats: stats,
                recommendations: Array.from(recommendations),
                logs: Array.from(elements.debugLogs.children).map(el => el.textContent),
                frames: Array.from(elements.frameInspector.children).map(el => ({
                    header: el.querySelector('.frame-header')?.textContent,
                    data: el.querySelector('.frame-data')?.textContent
                }))
            };
            
            const blob = new Blob([JSON.stringify(debugData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `websocket-debug-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('Debug data exported', 'success');
        }
        
        // Clear logs
        function clearLogs() {
            elements.debugLogs.innerHTML = '<div class="log-entry log-info"><span class="timestamp">[Cleared]</span> Logs cleared</div>';
            elements.frameInspector.innerHTML = '<div class="log-entry log-info">Frame inspector cleared</div>';
            stats = {
                messagesOut: 0,
                messagesIn: 0,
                bytesOut: 0,
                bytesIn: 0,
                reconnects: 0,
                errors: 0
            };
            updateStats();
            log('Logs and statistics cleared', 'info');
        }
        
        // Event listeners
        elements.connectBtn.addEventListener('click', connectWebSocket);
        elements.disconnectBtn.addEventListener('click', disconnectWebSocket);
        elements.testAudioBtn.addEventListener('click', testAudioRecording);
        elements.recordBtn.addEventListener('click', startRecording);
        elements.stopBtn.addEventListener('click', stopRecording);
        elements.clearLogsBtn.addEventListener('click', clearLogs);
        elements.exportLogsBtn.addEventListener('click', exportDebugData);
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            detectBrowserInfo();
            runSecurityCheck();
            updateStats();
            
            // Check Socket.IO version
            if (typeof io !== 'undefined') {
                document.getElementById('socketVersion').textContent = '4.x (CDN)';
            }
            
            log('WebSocket debugger initialized', 'success', {
                browser: document.getElementById('browserInfo').textContent,
                wsSupport: document.getElementById('wsSupport').textContent,
                socketIOLoaded: typeof io !== 'undefined'
            });
        });
        
        // Auto-connect on load (optional)
        window.addEventListener('load', () => {
            // Uncomment to auto-connect
            // setTimeout(connectWebSocket, 1000);
        });
    </script>
</body>
</html>