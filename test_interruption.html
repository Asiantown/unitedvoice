<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Interruption & Spacebar Recording Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 25px;
            margin: 20px 0;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .test-section h3 {
            margin-bottom: 15px;
            font-size: 1.4rem;
            color: #fff;
        }
        
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status::before {
            content: '';
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .success { 
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid #10b981;
            color: #d1fae5;
        }
        
        .success::before { background: #10b981; }
        
        .error { 
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fecaca;
        }
        
        .error::before { background: #ef4444; }
        
        .warning { 
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid #f59e0b;
            color: #fef3c7;
        }
        
        .warning::before { background: #f59e0b; }
        
        .info { 
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
            color: #dbeafe;
        }
        
        .info::before { background: #3b82f6; }
        
        .pending {
            background: rgba(107, 114, 128, 0.2);
            border: 1px solid #6b7280;
            color: #e5e7eb;
        }
        
        .pending::before { background: #6b7280; }
        
        button {
            padding: 12px 24px;
            margin: 8px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        button:hover:not(:disabled) { 
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        .record-button {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            padding: 16px 32px;
            font-size: 16px;
        }
        
        .record-button.recording {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        
        #logs {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff41;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 65, 0.3);
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .test-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        
        .connection-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6b7280;
            transition: all 0.3s ease;
        }
        
        .connection-indicator.connected {
            background: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        
        .audio-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
        }
        
        .instructions {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .instructions h4 {
            margin-bottom: 10px;
            color: #93c5fd;
        }
        
        .instructions ul {
            list-style: none;
            padding-left: 0;
        }
        
        .instructions li {
            padding: 5px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .instructions li::before {
            content: '→';
            position: absolute;
            left: 0;
            color: #3b82f6;
        }
        
        .audio-visualizer {
            width: 100%;
            height: 60px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="header">
            <h1>🎤 Audio Interruption & Spacebar Recording Test</h1>
            <p>Comprehensive testing suite for voice interface features</p>
        </div>

        <div class="instructions">
            <h4>📋 Test Instructions</h4>
            <ul>
                <li>This test verifies that audio can be interrupted by pressing spacebar</li>
                <li>Confirms that ONLY spacebar triggers recording (not mouse clicks)</li>
                <li>Tests WebSocket connectivity and audio streaming</li>
                <li>All tests run automatically - just follow the prompts</li>
                <li>Press spacebar when instructed to test recording</li>
                <li>Click buttons when instructed to test non-recording behavior</li>
            </ul>
        </div>

        <div class="connection-status">
            <div class="connection-indicator" id="connectionIndicator"></div>
            <span id="connectionText">Checking connection...</span>
            <div style="margin-left: auto;">
                <span id="connectionDetails"></span>
            </div>
        </div>

        <div class="test-grid">
            <div class="test-section">
                <h3>🔊 Audio Interruption Tests</h3>
                <div id="audio-test-results"></div>
                <div class="audio-controls">
                    <button id="playTestAudioBtn" onclick="playTestAudio()">Play Test Audio</button>
                    <div class="audio-visualizer" id="audioVisualizer">
                        Audio visualization will appear here
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="audioProgress"></div>
                    </div>
                    <p style="font-size: 14px; opacity: 0.8;">Press SPACEBAR during audio playback to test interruption</p>
                </div>
            </div>

            <div class="test-section">
                <h3>🎯 Spacebar-Only Recording Tests</h3>
                <div id="recording-test-results"></div>
                <div class="audio-controls">
                    <button class="record-button" id="recordButton" onmousedown="handleMouseDown()" onmouseup="handleMouseUp()">
                        Click Me (Should NOT Record)
                    </button>
                    <p style="font-size: 14px; opacity: 0.8;">
                        Click the button above - it should NOT start recording<br>
                        Press and hold SPACEBAR - it SHOULD start recording
                    </p>
                    <div id="recordingStatus" class="status info" style="display: none;">
                        <span id="recordingStatusText">Ready to test</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>🔧 Manual Test Controls</h3>
            <div class="control-panel">
                <button onclick="testWebSocketConnection()">Test WebSocket Connection</button>
                <button onclick="testMicrophoneAccess()">Test Microphone Access</button>
                <button onclick="testAudioPlayback()">Test Audio System</button>
                <button onclick="runSpacebarTest()">Run Spacebar Test</button>
                <button onclick="runInterruptionTest()">Run Interruption Test</button>
                <button onclick="runFullTestSuite()">Run Complete Test Suite</button>
                <button onclick="clearAllTests()">Clear All Results</button>
            </div>
        </div>

        <div class="test-section">
            <h3>📊 Test Results Summary</h3>
            <div id="test-results-summary"></div>
        </div>

        <div class="test-section">
            <h3>📝 Test Logs</h3>
            <div id="logs"></div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
        // Test state management
        let testResults = {};
        let socket = null;
        let audioContext = null;
        let currentAudioSource = null;
        let isRecordingFromSpacebar = false;
        let isRecordingFromMouse = false;
        let hasTestedMouseClick = false;
        let hasTestedSpacebar = false;
        let mediaRecorder = null;
        let audioStream = null;

        // Initialize on page load
        window.addEventListener('load', initializeTests);
        
        function initializeTests() {
            log('🚀 Initializing Audio Interruption & Spacebar Recording Test Suite...', 'info');
            setupEventListeners();
            setTimeout(runFullTestSuite, 1000);
        }

        function setupEventListeners() {
            // Spacebar event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Prevent default spacebar scrolling
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                }
            });
        }

        function handleKeyDown(event) {
            if (event.code === 'Space' && !event.repeat) {
                log('⌨️ Spacebar pressed - testing recording trigger', 'info');
                
                // Test spacebar interruption during audio
                if (currentAudioSource && !currentAudioSource.ended) {
                    log('🛑 Spacebar pressed during audio - testing interruption', 'warning');
                    interruptAudio();
                    updateTestResult('Audio Interruption via Spacebar', 'success', 'Audio successfully interrupted by spacebar');
                }
                
                // Test spacebar recording
                if (!isRecordingFromSpacebar) {
                    startSpacebarRecording();
                }
                
                hasTestedSpacebar = true;
            }
        }

        function handleKeyUp(event) {
            if (event.code === 'Space') {
                log('⌨️ Spacebar released', 'info');
                if (isRecordingFromSpacebar) {
                    stopSpacebarRecording();
                }
            }
        }

        function handleMouseDown() {
            log('🖱️ Mouse button pressed on record button', 'warning');
            hasTestedMouseClick = true;
            
            if (!isRecordingFromMouse) {
                // This should NOT start recording
                log('❌ Mouse click should NOT trigger recording', 'error');
                updateTestResult('Mouse Click Recording Prevention', 'success', 'Mouse click correctly did NOT start recording');
            } else {
                log('⚠️ WARNING: Mouse click started recording (this is incorrect behavior)', 'error');
                updateTestResult('Mouse Click Recording Prevention', 'error', 'Mouse click incorrectly started recording');
            }
        }

        function handleMouseUp() {
            log('🖱️ Mouse button released', 'info');
            if (isRecordingFromMouse) {
                // This should not happen, but if it does, stop it
                isRecordingFromMouse = false;
            }
        }

        async function testWebSocketConnection() {
            log('🌐 Testing WebSocket connection to backend...', 'info');
            updateConnectionStatus('connecting', 'Connecting to WebSocket...');
            
            try {
                socket = io('http://localhost:8000', {
                    transports: ['websocket', 'polling'],
                    timeout: 10000,
                    reconnection: false
                });

                return new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        log('❌ WebSocket connection timeout', 'error');
                        updateTestResult('WebSocket Connection', 'error', 'Connection timeout after 10 seconds');
                        updateConnectionStatus('error', 'Connection failed');
                        resolve(false);
                    }, 10000);

                    socket.on('connect', () => {
                        clearTimeout(timeout);
                        log('✅ WebSocket connected successfully!', 'success');
                        updateTestResult('WebSocket Connection', 'success', `Connected with ID: ${socket.id}`);
                        updateConnectionStatus('connected', `Connected (ID: ${socket.id.substring(0, 8)}...)`);
                        resolve(true);
                    });

                    socket.on('connect_error', (error) => {
                        clearTimeout(timeout);
                        log(`❌ WebSocket connection error: ${error.message}`, 'error');
                        updateTestResult('WebSocket Connection', 'error', error.message);
                        updateConnectionStatus('error', 'Connection failed');
                        resolve(false);
                    });

                    socket.on('disconnect', (reason) => {
                        log(`🔌 WebSocket disconnected: ${reason}`, 'warning');
                        updateConnectionStatus('disconnected', 'Disconnected');
                    });

                    // Test socket events for audio
                    socket.on('tts_audio', (data) => {
                        log('🎵 Received TTS audio from server', 'info');
                    });

                    socket.on('audio_received', (data) => {
                        log(`📨 Server confirmed audio receipt: ${data.success}`, 'info');
                    });
                });
            } catch (error) {
                log(`❌ Failed to create WebSocket connection: ${error.message}`, 'error');
                updateTestResult('WebSocket Connection', 'error', error.message);
                updateConnectionStatus('error', 'Failed to connect');
                return false;
            }
        }

        async function testMicrophoneAccess() {
            log('🎤 Testing microphone access...', 'info');
            
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                log('✅ Microphone access granted', 'success');
                updateTestResult('Microphone Access', 'success', 'Access granted successfully');

                // Test MediaRecorder compatibility
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/ogg;codecs=opus'
                ];

                let supportedMimeType = null;
                for (const mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        supportedMimeType = mimeType;
                        break;
                    }
                }

                if (supportedMimeType) {
                    log(`✅ MediaRecorder supported with MIME type: ${supportedMimeType}`, 'success');
                    updateTestResult('MediaRecorder Support', 'success', `Supported: ${supportedMimeType}`);
                } else {
                    log('❌ No supported MediaRecorder MIME types found', 'error');
                    updateTestResult('MediaRecorder Support', 'error', 'No supported MIME types');
                    return false;
                }

                return true;
            } catch (error) {
                log(`❌ Microphone access denied: ${error.message}`, 'error');
                updateTestResult('Microphone Access', 'error', error.message);
                return false;
            }
        }

        async function testAudioPlayback() {
            log('🔊 Testing audio playback system...', 'info');
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Create a test tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 440; // A note
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
                log('✅ Audio playback test completed', 'success');
                updateTestResult('Audio Playback System', 'success', 'Test tone played successfully');
                
                return true;
            } catch (error) {
                log(`❌ Audio playback test failed: ${error.message}`, 'error');
                updateTestResult('Audio Playback System', 'error', error.message);
                return false;
            }
        }

        async function playTestAudio() {
            log('🎵 Playing test audio for interruption test...', 'info');
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Create a longer test audio (5 seconds)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Create a more complex tone that changes frequency
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 2.5);
                oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 5);
                
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                
                currentAudioSource = oscillator;
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 5);
                
                // Update progress bar
                updateAudioProgress(5000);
                
                oscillator.onended = () => {
                    log('🎵 Test audio playback completed', 'info');
                    currentAudioSource = null;
                    document.getElementById('audioProgress').style.width = '0%';
                    document.getElementById('audioVisualizer').textContent = 'Audio visualization will appear here';
                };
                
                document.getElementById('audioVisualizer').textContent = '🎵 Playing test audio... Press SPACEBAR to interrupt!';
                log('📢 Press SPACEBAR now to test audio interruption!', 'warning');
                
            } catch (error) {
                log(`❌ Failed to play test audio: ${error.message}`, 'error');
            }
        }

        function updateAudioProgress(duration) {
            const progressBar = document.getElementById('audioProgress');
            const startTime = Date.now();
            
            const updateProgress = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                progressBar.style.width = `${progress}%`;
                
                if (progress < 100 && currentAudioSource) {
                    requestAnimationFrame(updateProgress);
                } else {
                    progressBar.style.width = '0%';
                }
            };
            
            requestAnimationFrame(updateProgress);
        }

        function interruptAudio() {
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                    currentAudioSource = null;
                    document.getElementById('audioProgress').style.width = '0%';
                    document.getElementById('audioVisualizer').textContent = '⏹️ Audio interrupted by spacebar!';
                    log('✅ Audio successfully interrupted by spacebar', 'success');
                } catch (error) {
                    log(`❌ Failed to interrupt audio: ${error.message}`, 'error');
                }
            }
        }

        function startSpacebarRecording() {
            if (isRecordingFromSpacebar) return;
            
            log('🎤 Starting recording triggered by SPACEBAR', 'success');
            isRecordingFromSpacebar = true;
            
            const recordingStatus = document.getElementById('recordingStatus');
            const recordingStatusText = document.getElementById('recordingStatusText');
            
            recordingStatus.style.display = 'flex';
            recordingStatus.className = 'status success';
            recordingStatusText.textContent = '🔴 Recording from SPACEBAR (CORRECT)';
            
            // Simulate recording with WebSocket
            if (socket && socket.connected) {
                socket.emit('start_recording', { timestamp: Date.now() });
            }
            
            // Start actual recording if we have audio stream
            if (audioStream) {
                try {
                    mediaRecorder = new MediaRecorder(audioStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    mediaRecorder.start(100);
                    log('🎤 MediaRecorder started for spacebar recording', 'info');
                } catch (error) {
                    log(`⚠️ MediaRecorder failed but spacebar trigger worked: ${error.message}`, 'warning');
                }
            }
            
            updateTestResult('Spacebar Recording Trigger', 'success', 'Spacebar correctly triggered recording');
        }

        function stopSpacebarRecording() {
            if (!isRecordingFromSpacebar) return;
            
            log('⏹️ Stopping spacebar-triggered recording', 'info');
            isRecordingFromSpacebar = false;
            
            const recordingStatus = document.getElementById('recordingStatus');
            const recordingStatusText = document.getElementById('recordingStatusText');
            
            recordingStatus.className = 'status info';
            recordingStatusText.textContent = '⏹️ Recording stopped (spacebar released)';
            
            // Stop WebSocket recording signal
            if (socket && socket.connected) {
                socket.emit('stop_recording', { timestamp: Date.now() });
            }
            
            // Stop MediaRecorder
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                log('⏹️ MediaRecorder stopped', 'info');
            }
            
            // Hide status after a delay
            setTimeout(() => {
                recordingStatus.style.display = 'none';
            }, 2000);
        }

        async function runSpacebarTest() {
            log('🧪 Running spacebar-only recording test...', 'info');
            
            updateTestResult('Spacebar Test', 'pending', 'Waiting for user interaction...');
            
            // Reset test state
            hasTestedMouseClick = false;
            hasTestedSpacebar = false;
            
            log('📢 Please click the red button above - it should NOT start recording', 'warning');
            log('📢 Then press and hold SPACEBAR - it SHOULD start recording', 'warning');
            
            // Wait for both interactions
            const checkTestCompletion = setInterval(() => {
                if (hasTestedMouseClick && hasTestedSpacebar) {
                    clearInterval(checkTestCompletion);
                    updateTestResult('Spacebar Test', 'success', 'Both mouse and spacebar interactions tested successfully');
                    log('✅ Spacebar-only recording test completed successfully!', 'success');
                }
            }, 500);
            
            // Timeout after 30 seconds
            setTimeout(() => {
                clearInterval(checkTestCompletion);
                if (!hasTestedMouseClick || !hasTestedSpacebar) {
                    updateTestResult('Spacebar Test', 'warning', 'Test incomplete - user interaction required');
                }
            }, 30000);
        }

        async function runInterruptionTest() {
            log('🧪 Running audio interruption test...', 'info');
            
            updateTestResult('Interruption Test', 'pending', 'Playing test audio...');
            
            // Play test audio automatically
            await playTestAudio();
            
            log('📢 Test audio is playing - press SPACEBAR to test interruption!', 'warning');
            
            // Check if interruption was tested within 6 seconds
            setTimeout(() => {
                if (currentAudioSource) {
                    // Audio is still playing, test failed
                    updateTestResult('Interruption Test', 'warning', 'Audio was not interrupted - spacebar may not have been pressed');
                    log('⚠️ Audio interruption test incomplete - spacebar was not pressed', 'warning');
                    currentAudioSource.stop();
                    currentAudioSource = null;
                } else {
                    // Audio was interrupted, test may have passed
                    log('✅ Audio interruption test may have completed', 'info');
                }
            }, 6000);
        }

        async function runFullTestSuite() {
            log('🚀 Starting complete test suite...', 'info');
            
            // Clear previous results
            testResults = {};
            renderTestResults();
            
            try {
                // 1. Test WebSocket Connection
                const wsConnected = await testWebSocketConnection();
                await delay(1000);
                
                // 2. Test Microphone Access
                const micAccess = await testMicrophoneAccess();
                await delay(1000);
                
                // 3. Test Audio Playback
                const audioPlayback = await testAudioPlayback();
                await delay(1000);
                
                // 4. Run interactive tests
                log('📢 Starting interactive tests...', 'info');
                log('📢 Follow the prompts to complete the full test suite', 'warning');
                
                // Start spacebar test
                await runSpacebarTest();
                
                // Start interruption test after a delay
                setTimeout(() => {
                    runInterruptionTest();
                }, 3000);
                
                // Generate summary after all tests
                setTimeout(() => {
                    generateTestSummary();
                }, 10000);
                
            } catch (error) {
                log(`❌ Test suite error: ${error.message}`, 'error');
            }
        }

        function generateTestSummary() {
            log('📊 Generating test summary...', 'info');
            
            const summary = document.getElementById('test-results-summary');
            const totalTests = Object.keys(testResults).length;
            const passedTests = Object.values(testResults).filter(r => r.result === 'success').length;
            const failedTests = Object.values(testResults).filter(r => r.result === 'error').length;
            const warningTests = Object.values(testResults).filter(r => r.result === 'warning').length;
            const pendingTests = Object.values(testResults).filter(r => r.result === 'pending').length;
            
            const passRate = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;
            
            let summaryClass = 'success';
            if (failedTests > 0) summaryClass = 'error';
            else if (warningTests > 0 || pendingTests > 0) summaryClass = 'warning';
            
            summary.innerHTML = `
                <div class="status ${summaryClass}">
                    <strong>Test Summary</strong>: ${passedTests}/${totalTests} tests passed (${passRate}%)
                    ${failedTests > 0 ? `| ${failedTests} failed` : ''}
                    ${warningTests > 0 ? `| ${warningTests} warnings` : ''}
                    ${pendingTests > 0 ? `| ${pendingTests} pending` : ''}
                </div>
            `;
            
            log(`📊 Test Summary: ${passedTests}/${totalTests} passed (${passRate}%)`, passRate === 100 ? 'success' : 'warning');
        }

        function updateConnectionStatus(status, message, details = '') {
            const indicator = document.getElementById('connectionIndicator');
            const text = document.getElementById('connectionText');
            const detailsEl = document.getElementById('connectionDetails');
            
            indicator.className = `connection-indicator ${status}`;
            text.textContent = message;
            detailsEl.textContent = details;
        }

        function updateTestResult(testName, result, message) {
            testResults[testName] = { 
                result, 
                message, 
                timestamp: new Date() 
            };
            renderTestResults();
        }

        function renderTestResults() {
            // Render audio test results
            const audioResults = document.getElementById('audio-test-results');
            const recordingResults = document.getElementById('recording-test-results');
            
            let audioHTML = '';
            let recordingHTML = '';
            
            Object.entries(testResults).forEach(([testName, data]) => {
                const html = `
                    <div class="status ${data.result}">
                        <strong>${testName}</strong>: ${data.message}
                        <small style="margin-left: auto; opacity: 0.8;">${data.timestamp.toLocaleTimeString()}</small>
                    </div>
                `;
                
                if (testName.includes('Interruption') || testName.includes('Audio')) {
                    audioHTML += html;
                } else if (testName.includes('Spacebar') || testName.includes('Recording') || testName.includes('Mouse')) {
                    recordingHTML += html;
                }
            });
            
            audioResults.innerHTML = audioHTML || '<div class="status info">No audio test results yet</div>';
            recordingResults.innerHTML = recordingHTML || '<div class="status info">No recording test results yet</div>';
        }

        function clearAllTests() {
            testResults = {};
            renderTestResults();
            document.getElementById('logs').innerHTML = '';
            document.getElementById('test-results-summary').innerHTML = '';
            log('🧹 All test results cleared', 'info');
        }

        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            
            let icon = '📝';
            if (type === 'success') icon = '✅';
            else if (type === 'error') icon = '❌';
            else if (type === 'warning') icon = '⚠️';
            else if (type === 'info') icon = 'ℹ️';
            
            const logEntry = `[${timestamp}] ${icon} ${message}`;
            logs.innerHTML += logEntry + '\n';
            logs.scrollTop = logs.scrollHeight;
            
            console.log(`[INTERRUPTION-TEST] ${logEntry}`);
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (socket) socket.disconnect();
            if (audioStream) audioStream.getTracks().forEach(track => track.stop());
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
        });
    </script>
</body>
</html>